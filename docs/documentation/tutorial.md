---
layout: documentation
title: Overview
id: overview
section: documentation
---

## Getting Started

### Maven Archetype

Dari provides a Maven archetype to help you quickly setup a new Dari web
project. After running this command you will have a project directory
named after the `artifacedId` you provided.

This archetype has been tested with Maven version 3.x.

    mvn archetype:generate -B \
        -DarchetypeRepository=http://public.psddev.com/maven \
        -DarchetypeGroupId=com.psddev \
        -DarchetypeArtifactId=dari-app-archetype \
        -DarchetypeVersion=2.0-SNAPSHOT \
        -DgroupId=com.yourcompany  \
        -DartifactId=yourproject

### Maven Archetype Setup

The directory generated by the Maven archetype is a standard Maven web
project. A settings.properties file configured to use the Java
H2 database is provided along with a simple index page.  For the purposes
of this tutorial, all Java classes should be placed in the
**src/main/java/demo/poll** directory.

    pom.xml
    src/main/java/demo/poll/DefaultRouter.java
    src/main/resources/settings.properties
    src/main/webapp/index.jsp
    src/main/webapp/WEB-INF/web.xml

### Running the Application

You can run the application using the Jetty maven plugin.

    mvn package cargo:run

After Tomcat starts up browse to
[http://localhost:8080](http://localhost:8080) to see the
default Dari webpage.


### Debugging Tools

As part of the Dari distribution you are provided with a suite of debugging
tools that will aide you in the development process. They can all be accessed
from your browser at http://localhost:8080/_debug/ and individually by appending
the tool name to the end of the URL. A few key ones referenced in this tutorial
are outlined below. For a full more detailed list refer to the
**debugging tools** section of the documentation.

code
: Execute arbitrary blocks of code, create new Java files, and edit existing
Java and JSP files.

db-bulk
: Run bulk operations such as copying one database to another and index
existing databases.

db-schema
: A visualization of the object model.

query
: Database agnostic query interface, coupled with an object data editor.

stats
: Global application performance monitoring.

task
: Background task monitoring with controls to stop, start, and pause taks.


### Writing you first Dari Application ###

Now let's build a simple Polls application. At the end of this tutorial you 
should have a basic understanding of how to model and querying data using Dari,
as well as some of the web-based tools available that make it easy to work with
Dari.

We're going to model a simple Poll application that allows users to take a poll
and view the polls results.

Dari differs from a traditional ORM in that it does not map Java classes to
individual database tables. Instead it stores data in a schema-less format that
is appropriate for the underlying database. For RDBMS this format is a JSON
blob. Storing data as a JSON blob frees Dari from needing to manage schema
evolution which allows for rapid data model changes. This is a very powerful
feature.

Let's start off by creating a few simple Java classes that we will need for our
Polls application.

<div class="alert alert-block">
    <strong>TIP:</strong>
    <p>You can create new Java classes directly from your browser by using the
    <strong>code</strong> debug tool, selecting <strong>NEW CLASS</strong> from
    the dropdown, pasting the code into the editor and clicking Save.</p>
</div>

{% highlight java %}
package demo.poll;

import com.psddev.dari.db.*;
import com.psddev.dari.util.*;
import java.util.*;

public class Poll extends Record {
    private String question;
    private List<Answer> answers;
    
    public String getQuestion() {
        return question;
    }
    public void setQuestion(String question) {
        this.question = question;
    }
    public List<Answer> getAnswers() {
        return answers;
    }
    public void setAnswers(List<Answer> answers) {
        this.answers = answers;
    }
}
{% endhighlight %}
---
{% highlight java %}
package demo.poll;

import com.psddev.dari.db.*;
import com.psddev.dari.util.*;
import java.util.*;

public class Answer extends Record {
    private String answer;

    public String getAnswer() {
        return answer;
    }
    public void setAnswer(String answer) {
        this.answer = answer;
    }
}
{% endhighlight %}
---
{% highlight java %}
package demo.poll;

import com.psddev.dari.db.*;
import com.psddev.dari.util.*;
import java.util.*;

public class User extends Record {
    private String userName;
    private String firstName;
    private String lastName;
    
    public String getUserName() {
        return userName;
    }
    public void setUserName(String userName) {
        this.userName = userName;
    }
}
{% endhighlight %}

All Dari objects must extend `com.psddev.dari.db.Record`. This is all that is
needed to start persisting object data.

In order for Dari to recognize newly created classes we have to reload the
application.  This can be done without restarting the server by adding the
parameter `_reload=true` to the current browser location and reloading the page
like so:

    http://localhost:8080/_debug/?_reload=true

Dari is now aware of our new data model.  Lets see the visual representation of
it using the `schema` debug tool. Once there select `demo.poll.Poll` and
`demo.poll.User` from the dropdown and click View.  This is exactly what we
expect so lets move on.

![Poll Example 1](img/tutorial/poll01.png)

As part of our Poll application we need the ability to create new users as well
as fetch existing ones.  Let's add a some static methods to the User class to
do just that.

<div class="alert alert-block">
    <strong>TIP:</strong>
    <p>You can also edit existing Java classes directly from your browser by
    using the <strong>code</strong> debug tool. Select the class you want to
    edit from the dropdown, make changes, and click Save.</p>
</div>

{% highlight java %}
public class User extends Record {
    // ... fields, getters, setters...

    public static User createUser(String userName) {
        if (userName == null || "".equals(userName = userName.trim()) {
            return null;
        } else {
            User user = new User();
            user.setUserName(userName);
            user.save();
            return user;
        }
    }

    public static User getUser(String userName) {
        return Query.from(User.class)
                .where("userName = ?", userName)
                .first();
    }
}
{% endhighlight %}

Here we introduce the `save()` API which is inherited from `Record` and the
`com.psddev.dari.db.Query` API.  Calling `save()` on an instantiated object
is all that it takes to persist objects in Dari.  Similarly, the `Query` API
provides all the necessary methods to retrieve persisted objects.  The `Query`
syntax is based on
<a href="http://msdn.microsoft.com/en-us/netframework/aa904594.aspx">LINQ</a>
and <a href="http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/Predicates/predicates.html">Cocoa Predicates</a>.
For more information on querying refer to the [Querying section](querying.html)
of the documentation.

If you haven't tried the `code` editor debug tool already, we'll use it now
to save some users.  Paste the following snippet into the `code` editor and
click **Run**:

{% highlight java %}
import com.psddev.dari.db.*;
import com.psddev.dari.util.*;
import demo.poll.*;
import java.util.*;

public class Code {
    public static Object main() throws Throwable {
        String[] names = {"Hyoo", "Jeremy", "Kelly", "Dan", "David"};

        List<User> createdUsers = new ArrayList<User>();

        for (String name : names) {
            User user = User.createUser(name);
            if (user != null) {
                createdUsers.add(user);
            }
        }

        return createdUsers;
    }
}
{% endhighlight %}

We return the list of created users so the `code` editor outputs the
internal representation of each of the items as seen below:

![Poll Example 2](img/tutorial/poll02.png)

However, this doesn't mean that our objects were actually saved to the
underlying database.  If we removed the call to `save()` in our
`User.createUser()` method the code editor would still print the same thing.
Let's replace the code in the editor with the following to verify our objects
were saved, and click **Run**.

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {
        return Query.from(User.class).selectAll();
    }
}
{% endhighlight %}

Indeed, we get the same output because the `selectAll()` API also returns a list
of objects.

Let's test the other method we wrote and query for a specific user. Paste
the following snippet into the code editor and click **Run**.

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {
        return User.getUser("David");
    }
}
{% endhighlight %}

![Poll Example 4](img/tutorial/poll04.png)

Oops! We get an error! Let's take a step back from our code and use the `query`
debug tool to try the same query.  Once inside the `query` tool, select
User (demo.poll.User) from the TYPES dropdown. Then in the text area right
below type:

    userName = "David"

and then click **Run**: 

![Poll Example 3](img/tutorial/poll03.png)

Indeed we get the same error.  Specifically, it says `Can't query
[demo.poll.User/userName] because it's not indexed!`  In Dari, any time you
query on a specific field or fields, those fields must be annotated with
`@Indexed`. Let's go back and update all of our classes to have this annotation.

{% highlight java %}
public class Poll extends Record {
    @Indexed private String question;
    private List<Answer> answers;

    // ... getters, setters ...
}

public class Answer extends Record {
    @Indexed private String answer;

    // ... getters, setters ...
}

public class User extends Record {
    @Indexed private String userName;
    private String firstName;
    private String lastName;

    // ... getters, setters ...
}
{% endhighlight %}

<div class="alert alert-block">
    <strong>TIP:</strong>
    <p>It is a common mistake to get carried away and add the @Indexed
    annotation to all the fields on every class you create.  Doing so creates
    extra potentially unnecessary rows in the underlying database and can lead
    to poor performance in systems with large amounts of data. Only add the
    annotation to fields that you think you will query on.</p>
</div>

Before re-running our query we need to once again trigger the reloader to make
sure Dari picks up our changes.  Add the `_reload=true` parameter to your current
URL again like so:

    http://localhost:8080/_debug/?_reload=true

<div class="alert alert-block">
    <strong>NOTE:</strong>
    <p>With Dari, when you make changes to your code, it is compiled
    automatically and reflected on the server.  Some changes require the
    entire application to reload in order to reflect them properly, while
    others do not and will be reflected immediately.  Changes that affect
    Dari's internal representation of your classes but don't trigger an
    application reload will cause Dari not to see those changes.  Adding new
    Java files and adding annotations to fields are 2 such examples of this
    which is why we must resort to manually reloading the app.  Most other
    times reloading will happen automatically and there's no additional
    effort on your part.</p>
</div>

Now let's try to re-run our query. (Don't forget to select User from dropdown
first!).

![Poll Example 5](img/tutorial/poll05.png)

Ooops! No results were found. This happens because our User objects were saved
prior to adding the `@Indexed` annotation, so it only applies to new objects
that we create.  The `db-bulk` debug tool can help us here.  We will use the
**Indexer** to fix the indexes on the objects that are missing them.  Select
`demo.poll.User` from the dropdown leaving the other fields as their defaults 
for now, and click Start.  This kicks off a background task that we can monitor
in yet another Dari debug tool, `task`, by clicking the link generated under
**Ongoing Tasks**.

![Poll Example 6](img/tutorial/poll06.png)

We won't go into detail about the `task` tool now, instead lets retry our query
again to make sure our fields are indexed.

Voila!! 1 result found for "David".  And we can verify the same using our code
snippet from earlier.

![Poll Example 7](img/tutorial/poll07.png)

Before moving on, let's take a quick look at some of the additional features the
`query` tool has to offer. Clicking a result hyperlink yields a popup that lets us view and edit the raw
JSON representation of the object, as well as a tab presenting an auto-generated
UI where we can easily change the field values on the object and save them.
Cool!

![Poll Example 8](img/tutorial/poll08.png)
![Poll Example 9](img/tutorial/poll09.png)

Now that we've got the basics of querying down, lets get back to creating that
Poll application.  We're going to create a new method on Poll
`createPoll(String, List<String>)` and also go back and merge our two User
methods into one method `getOrCreateUser(String)`.

{% highlight java %}
public class Poll extends Record {
    // ... fields, getters, setters ...

    public static Poll createPoll(String question, List<String> answerStrings) {
        Poll poll = new Poll();
        poll.setQuestion(question);

        List<Answer> answers = new ArrayList<Answer>();

        if (answerStrings != null) for (String answerString : answerStrings) {
            Answer answer = new Answer();
            answer.setAnswer(answerString);
            answer.save();
            answers.add(answer);
        }
        poll.setAnswers(answers);
        poll.save();
        return poll;
    }
}
{% endhighlight %}
---
{% highlight java %}
public class User extends Record {
    // ... fields, getters, setters ...

    public static User getOrCreateUser(String userName) {

        User user = Query.from(User.class)
                .where("userName = ?", userName)
                .first();

        if (user == null) {
            if (userName == null || "".equals(userName = userName.trim()) {
                return null;
            } else {
                User user = new User();
                user.setUserName(userName);
                user.save();
                return user;
            }
        } else {
            return user;
        }
    }
}
{% endhighlight %}

Additionally, we need a way to store a user's response to the poll so we'll
create a brand new object `UserResponse` remembering this time to include
the `@Indexed` annotation. And then create an instance method on Poll called
`submit(User, Answer)`.

{% highlight java %}
package demo.poll;

import com.psddev.dari.db.*;
import com.psddev.dari.util.*;
import java.util.*;

public class UserResponse extends Record {

    @Indexed private User user;
    @Indexed private Answer answer;

    public User getUser() {
        return user;
    }
    public void setUser(User user) {
        this.user = user;
    }
    public Answer getAnswer() {
        return answer;
    }
    public void setAnswer(Answer answer) {
        this.answer = answer;
    }
}
{% endhighlight %}
---
{% highlight java %}
public class Poll extends Record {
    // ... fields, getters, setters, other methods ...

    public UserResponse submit(User user, Answer answer) {

        if (user != null && this.getAnswers().contains(answer)) {
            UserResponse response = new UserResponse();
            response.setUser(user);
            response.setAnswer(answer);
            response.save();
            return response;

        } else {
            return null;
        }
    }
}
{% endhighlight %}

Let's check out our updated model with the `db-schema` tool. Remember to
manually reload the application if it does not do it automatically. Select
`Poll` and `User Repsonse` from the dropdown. 

![Poll Example 10](img/tutorial/poll10.png)

Now that we have a full working model lets create some polls and responses that
we can play with. Back to the `code` tool!  Execute the following code:

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {
    
        List<Object> createdObjects = new ArrayList<Object>();

        Poll poll = Poll.createPoll("What is Dari?",
                java.util.Arrays.asList(
                "A content management system",
                "A Java development framework",
                "A bridge"));
        createdObjects.add(poll);

        List<Answer> answers = poll.getAnswers();
        createdObjects.addAll(answers);

        // Randomly assign an answer for the users
        int counter = 0;
        for (User user : Query.for(User.class).selectAll()) {
            UserResponse response = poll.submit(user, answers.get(counter % 3));
            createdObjects.add(response);
            counter++;
        }
        
        return createdObjects;
    }
}
{% endhighlight %}

The output from the `code` tool shows us all the objects that we just created.

*** INSERT IMAGE HERE ? ***

The last thing we need to do is write a query that tells us how many responses
we got for our poll as well as the distribution of answers.  We'll start with
the first one and try to get the total count, which in our example should be 5.

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {

        Poll poll = Query.from(Poll.class)
                .where("question = ?", "What is Dari?")
                .first();

        List<Answer> answers = p.getAnswers();

        int responseCount = Query.from(UserResponse.class)
            .where("answer = ?", answers)
            .count();
        return responseCount;
    }
}
{% endhighlight %}

Perfect, 5 responses as expected.  This query is particularly interesting though
because we pass a `List<Answer>` into the query's predicate.  In our simple Poll
application this works just fine because we don't expect the size of the List
to be large.  But suppose we were working in a different problem space where the
list could grow to be hundreds or thousands of records.  This query is no longer
feasible because it is similar to the SQL `IN` clause where you have `id IN
(answerId1, answerId2, answerId3)`.  As the list grows larger as does the query
execution time. Let's try to alter our model to avoid this situation and still
be able to answer our question.  We'll remove the answers List from the Poll
object and instead place a Poll field on the Answer class.  Here are the updated
class files.

{% highlight java %}
public class Poll extends Record {
    @Indexed private String question;
    
    public String getQuestion() {
        return question;
    }
    public void setQuestion(String question) {
        this.question = question;
    }
    
    // ... helper methods ...
}
{% endhighlight %}
---
{% highlight java %}
public class Answer extends Record {
    private String answer;
    @Indexed Poll poll;

    public String getAnswer() {
        return answer;
    }
    public void setAnswer(String answer) {
        this.answer = answer;
    }
    public Poll getPoll() {
        return poll;
    }
    public void setPoll(Poll poll) {
        this.poll = poll;
    }
}
{% endhighlight %}

We also need to update our Poll helper methods to accomodate the new model.
Here are the updated methods along with a new `getAnswers()` method that relies
on a query instead of the instance variable we just removed.

{% highlight java %}
public class Poll extends Record {
    // ... fields, getters, setters ...
    
    public static Poll createPoll(String question, List<String> answerStrings) {

        Poll poll = new Poll();
        poll.setQuestion(question);
        poll.save();

        if (answerStrings != null) for (String answerString : answerStrings) {
            Answer answer = new Answer();
            answer.setPoll(poll);
            answer.setAnswer(answerString);
            answer.save();
        }

        return poll;
    }

    public List<Answer> getAnswers() {
        return Query.from(Answer.class).where("poll = ?", this).selectAll();
    }

    public UserResponse submit(User user, Answer answer) {

        if (user != null && answer != null && answer.is("poll = ?", this)) {
            UserResponse response = new UserResponse();
            response.setUser(user);
            response.setAnswer(answer);
            response.save();
            return response;

        } else {
            return null;
        }
    }
}
{% endhighlight %}

In this revised example we introduce another method `is()` inherited from
Record.  It uses the Query syntax to check if object matches the predicate. In
this case we are verifying that the supplied answer object actually belongs to
the current poll.

Let's take one last look at our schema by selecting just `UserResponse` from
the `db-schema` tool dropdown.  All of our objects are accessible now from
the `UserResponse` object.

![Poll Example 10](img/tutorial/poll10.png)

Before we can attempt to rewrite our response count query, we have a data issue
that needs our attention.  We removed a field that contained data, and then
added a field which now has no data. Let's write a quick script to fix our
existing polls.

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {

        for (Poll poll : Query.from(Poll.class).selectAll()) {

            List<Answer> answers = (List<Answer>) poll.getState().get("answers");

            if (answers != null) for (Answer answer : answers) {
                answer.setPoll(poll);
                answer.save();
            }

            poll.getState().put("answers", null);
            poll.save();
        }
    }
}
{% endhighlight %}

We introduce another new method, `getState()`, that is inherited from Record.
Even though we removed the `answers` field from our Poll class Dari doesn't
automatically delete the corresponding data.  It still lives on the object's
`State`. `State` is the backing `Map<String, Object>` for all Dari Records, and
can be accessed at any time.  In the above snippet we access the `answers`
field on each poll's State so we can re-associate based on the new model.  Once
we're finished we remove the `answers` field from the `State` so that we don't
have unused data hanging around.

Finally, we can try to write our response count query again.  To do so, we'll
make use of Dari sub-queries like so:

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {

        Poll poll = Query.from(Poll.class)
                .where("question = ?", "What is Dari?")
                .first();

        Quer<Answer> answersQuery = Query.from(Answer.class)
                .where("poll = ?", poll);

        int responseCount = Query.from(UserResponse.class)
                .where("answer = ?", answersQuery)
                .count();
        return responseCount;
    }
}
{% endhighlight %}

This looks very similar to our old query with the key difference being that
we're passing in a `Query` object to the predicate and NOT a `List`, AND we
never actually execute the `answersQuery`.  Dari optimizes the resulting
sub-query for execution on the underlying database.

Dealing with sub-queries like this often times makes our code difficult to read
so Dari provides a clean, concise syntax that we can use to achieve the same
effect.

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {

        Poll poll = Query.from(Poll.class)
                .where("question = ?", "What is Dari?")
                .first();

        int responseCount = Query.from(UserResponse.class)
                .where("answer/poll = ?", poll)
                .count();
        return responseCount;
    }
}
{% endhighlight %}

We're at the home stretch!  The last question we need to answer is what the
distribution of answers are for the poll.  This is done using `Query.groupBy()`
method, which is discussed in more detail in the
[Querying section](querying.html) of the documentation. Let's roll this method,
along with our previous one into our Poll class to complete the example.

{% highlight java %}
public class Poll extends Record {

    public Map<Answer, Long> getPollResults() {

        Map<Answer, Long> pollResults = new HashMap<Answer, Long>();

        Query<UserResponse> responseQuery = Query.from(UserResponse.class)
                .where("answer/poll = ?", this);

        for (Grouping<UserResponse> grouping : responseQuery.groupBy("answer")) {

            List<Object> keys = grouping.getKeys();
            Object key0 = keys.get(0);

            if (key0 instanceof Answer) {
                Answer answer = (Answer) key0;
                long answerCount = grouping.getCount();

                pollResults.put(answer, answerCount);
            }
        }

        return pollResults;
    }

    public long getPollResponseCount() {
        return Query.from(UserResponse.class)
                .where("answer/poll = ?", this)
                .count();
    }
}
{% endhighlight %}

Finally, let's test it out in the `code` tool.

{% highlight java %}
public class Code {
    public static Object main() throws Throwable {

        Poll poll = Query.from(Poll.class)
                .where("question = ?", "What is Dari?")
                .first();

        return poll.getPollResults();
    }
}
{% endhighlight %}

*** INSERT IMAGE HERE  ***

You can download the [full demo here](/assets/dari-poll-demo.tar.gz).

To install and run, simply uncompress the tarball:

    tar -xzf dari-poll-demo.tar.gz

Change to the directory:

    ls
    cd dari-poll-demo

And run the application with:

    mvn package cargo:run

In our next tutorial we will expand on our Poll example to introduce more Dari
concepts such as validation and transactions.  Stay Tuned!

For more information on Dari please refer to the rest of the documentation.
Thanks! Enjoy!

